在实际的编码过程中，有时有一些任务，需要事先做一些设置，事后做一些清理，这时就需要python with出场了，with能够对这样的需求进行一个比较优雅的处理，最常用的例子就是对访问文件的处理。


一般访问文件资源时我们会这样处理：
f = open(r'c:\test.txt', 'r')
data = f.read()
f.close()
这样写没有错，但是容易犯两个毛病：
1. 如果在读写时出现异常而忘了异常处理。
2. 忘了关闭文件句柄


以下的加强版本的写法：
f = open(r'c:\test.txt', 'r')
try:
    data = f.read()
finally:
    f.close()
以上的写法就可以避免因读取文件时异常的发生而没有关闭问题的处理了。代码长了一些。


但使用with有更优雅的写法：
with open(r'c:\test.txt', 'r') as f:
    data = f.read()
说明：
with后面接的对象返回的结果赋值给f。此例当中open函数返回的文件对象赋值给了f.with会自已获取上下文件的异常信息。
with是如何做到的呢？
with后面返回的对象要求必须两__enter__()/__exit__()这两个方法，而文件对象f刚好是有这两个方法的，故应用自如。
pytho中官方定义说明如下:

object.__enter__(self)
进入与此对象相关的运行时上下文。with语句将将此方法的返回值绑定到语句的AS子句中指定的目标（如果有设置的话）
 
object.__exit__(self, exc_type, exc_value, traceback)
退出与此对象相关的运行时上下文。参数描述导致上下文退出的异常。如果上下文运行时没有异常发生，那么三个参数都将置为None。
如果有异常发生，并且该方法希望抑制异常（即阻止它被传播），则它应该返回True。否则，异常将在退出该方法时正常处理。
 
请注意, __exit__()方法不应该重新抛出传入的异常，这是调用者的职责。

