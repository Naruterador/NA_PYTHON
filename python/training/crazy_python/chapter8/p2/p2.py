#coding=utf-8

'''
析构(destruct)方法:__del__

当程序不再需要一个python对象时，系统必须把该对象所占用的内存空间释放出来，这个过程被称为
垃圾回收(GC,Garbage collector),Python会自动回收所有对象所占用的内存空间，因此开发者无需
关心对象垃圾回收过程。
------------------------------------------------------------------------------------------
python采用自动引用计数(ARC)方式来回收对象所占空间，当程序中有一个变量引用该Python对象时,Python
会自动保证该对象引用计数为1，当程序中有两个变量引用该对象时，Python对象会自动保存该对象引用计数为2，依此类推
如果一个引用对象的引用计数变成了0，则说明程序中不再有变量引用该对象，表明程序不再需求该对象，因此Python就会回收
该对象。

大部分时候(ARC)都能准确、高效地回收系统的每个对象。但是如果出现循环引用的情况，比如对象a持有一个实例变量引用b
而对象b又持有一个实例变量引用对象a,此时两个对象的引用计数都是1，而实际上程序已经不再有变量引用它们，系统应该
回收它们。此时python的垃圾回收器就可能没那么块，要等专门的循环垃圾回收器(Cyclic Garbage Collector)并检测
回收这种引用循环。
-------------------------------------------------------------------------------------------

当一个对象被垃圾回收时，python就会自动调用该对象的__del__方法

注意:
不要以为对一个变量执行del操作，该变量所引用的对象就会被回收--只有当对象的引用计数变成0时，该对象才会被回收。因此
如果一个对象有多个变量引用它，那么del其中一个变量是不会回收对象的。

'''

class Item(object):
	def __init__(self,name,price):
		self.name = name
		self.price = price

	def __del__(self):
		print('del删除对象')

im = Item('鼠标',29.8)

x = im       #1

del im

print("-------------------------------")

'''
上面程序创建了Item对象，并将该对象赋值给IM变量，而后又将IM对象赋值给变量x
这样程序中就出现了2个引用ITEM对象，接下来程序执行del im代码删除im对象--此时由于
还有变量引用该ITEM对象，因此程序不会回收ITEM对象运行上面程序可以看到如下结果:

-------------------------------
del删除对象

从上面结果可以看出，del im执行之后，程序并没有回收Item对象，只有等到程序执行要结束时
系统才会回收Item对象。
如果将#1处的代码注释，输出结果为:

del删除对象
-------------------------------


说明:
如果父类提供了__del__()方法，则系统重写__del__()方法时必须显示调用父类的__del__()方法
这样才能保证合理地回收父类实例的部分属性。.



'''


