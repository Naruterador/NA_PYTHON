#coding = utf - 8




'''
生成器(generator)


生成器和迭代器的功能非常想次，它也会提供__next__()方法，这意味着程序
同样调用内置的next()函数来获取生成器的下一个值，也可以使用for循环来
遍历生成器。

生成器与迭代器的区别在于:迭代器通常是先定义一个迭代器类，然后通过创建实例来创建迭代器
而生成器则是先定义一个包含yield语句的函数，然后通过调用该函数来创建生成器。

生成器是一种非常优秀的语法，Python使用生成器可以使程序变的更加优雅。
'''



'''
创建生成器
1.定义一个包含yield语句的函数
2.点用第一步创建函数得到生成器

下面程序使用生成器来定义一个差值递增的数列。程序先定义了一个包含yield语句的函数
'''

def test(val,step):
	print("------函数开始执行--------")
	cur = 0
	#遍历0~val
	for i in range(val):
		#cur添加 i*step
		cur = cur + i * step
 
		#print(cur,end=" ")
		yield cur



'''
上面函数和普通函数最大区别就是yield cur这行，如果将这行改为print(cur),那么这个函数就比较
普通了--该函数就只做简单的遍历区间，并将计数器乘以step后添加到cur变量上，该数列两个值之间的
差会逐步递增。

如果将上面yield cur语句改为print(cur,end=''),执行test(10,2)输出如下:
0 2 6 12 20 30 42 56 72 90


yield语句的作用:
1.每次返回一个值，有点类似于return语句
2.冻结执行，程序每次执行到yield语句时就会被暂停

在程序被yield语句冻结之后，程序再次调用next函数获取生成器的下一个值时，程序才会继续向下执行。

调用包含yield语句的函数并不会立即执行，它只是返回一个生成器。只有当程序通过next()函数调用生成器
或遍历生成器时，函数才会真正执行


保留上面函数的yield cur语句，执行如下语句:
'''
#执行函数返回生成器
t = test(10,2)
print("===============")
#获取生成器的第一个值
print(next(t))          #生成器被冻结在yield处
#获取生成器的第二个值
print(next(t))          #生成器再次被冻结在yield处


'''
从上面输出结果来看，当程序执行t = test(10,2)调用函数时，程序并没有执行test函数；当程序第一次
调用next(t)时候，test函数才开始执行
'''

'''
Python 2.X不使用next()函数来获取生成器的下一个值，而是直接调用生成器的next()方法，所以在
Python 2.X中应该写成t.next()
'''

