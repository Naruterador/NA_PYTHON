# 迷宫游戏需求
<pre>
数字迷宫游戏

1.项目简介

数字迷宫是又0,1组成的一个m行n列的二维矩阵，例如：

0 0 0 1

0 0 0 0

0 0 1 0

就是一个3行4列的迷宫，其中每个元素是0或者1，一个小虫从左上角的(0,0)入口，只能向上下左右行走，而且只能到达元素值为0的点，
值为1的点不可以到达，然后从右下角的(2,3)点走出来，程序的功能就是为这个小虫找到所有的不重复的道路。
例如这个迷宫的道路一共有下列5条：

Path 1   :->(0,0)->(0,1)->(0,2)->(1,2)->(1,3)->(2,3)

Path 2   :->(0,0)->(0,1)->(1,1)->(1,2)->(1,3)->(2,3)

Path 3   :->(0,0)->(1,0)->(1,1)->(1,2)->(1,3)->(2,3)

Path 4   :->(0,0)->(1,0)->(1,1)->(0,1)->(0,2)->(1,2)->(1,3)->(2,3)

Path 5   :->(0,0)->(1,0)->(2,0)->(2,1)->(1,1)->(1,2)->(1,3)->(2,3)

Path 6   :->(0,0)->(1,0)->(2,0)->(2,1)->(1,1)->(0,1)->(0,2)->(1,2)->(1,3)->(2,3)

 






2.迷宫道路深度优先算法

先构造一个节点的类NodeClass如下：

class NodeClass:

    def __init__(self,i,j,v):

        self.i=i

        self.j=j

        self.v=v

其中(i,j)是一个节点位置，v=0,1,2,3是上下左右四个反向的走向。

构造一个栈stack，它的每个元素是一个NodeClass的对象，存储小虫走过的道路，算法如下：

(1) 把点(0,0,0)入栈，top=0；

(2) 如果栈不空，那么考虑栈顶的节点得到v=stack[top].v，然后让stack[top].v增加1以便下次朝着另外一个方向前进。

(3) 根据v=0,1,2,3确定新的位置(i,j)如下：

            if v==0:

                i=node.i

                j=node.j-1

            elif v==1:

                i=node.i

                j=node.j+1

            elif v==2:

                i=node.i-1

                j=node.j

            elif v==3:

                i=node.i+1

                j=node.j

如果(i,j)是可以到达的合理位置，而且目前道路上没有到过这个位置，那么就让这个节点入栈：
</pre>
            if v<4:

                if i>=0 and j>=0 and i<self.m and j<self.n:

                    flag=False

                    for k in range(top+1):

                        if stack[k].i==i and stack[k].j==j:

                            flag=True

                            break

                    if self.maze[i][j]==0 and not flag:

                        node=NodeClass(i,j,0)

                        stack.append(node)

                        top+=1

                        if i==self.m-1 and j==self.n-1:

                            count+=1

                            print("Path %-4d" %count,end=":")

                            for k in range(top+1):

                                print("->(%d,%d)" %(stack[k].i,stack[k].j),end="")

                            print()

                            stack.pop()

                            top-=1

            else:

                stack.pop()

                top-=1

(4) 如果新的节点(i,j)正好到达右下角(m-1,n-1)的位置就找到一条道路，接着退栈，再去找另外一条道路。

(5) 如果v=4，那么该节点已经没有可以去的下一个节点了，于是再次退栈。

(6) 这个过程一直进行下去，直到栈空为止。

 

3 迷宫道路广深度优先算法

先构造一个节点的类NodeClass如下：

class NodeClass:

    def __init__(self,i,j,v):

        self.i=i

        self.j=j

        self.v=v

其中(i,j)是一个节点位置，v=0,1,2,3是上下左右四个反向的走向。

构造一个队列queue，它的每个元素是一个NodeClass的对象，存储小虫走过的道路，算法如下：

(1) 把点(0,0,0)入队，first=0,rear=0；

(2) 如果first<=rear队不空，那么考虑对顶的节点得到node=queue[first]，然后找出这个点能到达的所有点像另外一个方向前进

(3) node是一个新的可以到达的点，如果node是(m-1,n-1)的终点，就显示道路。如果node不是终点。就把这个node加入队列，同时记录这个点的前序节点。

        while first<=rear:

            for v in range(4):

                node = queue[first]

                if v==0:

                    i=node.i

                    j=node.j-1

                elif v==1:

                    i=node.i

                    j=node.j+1

                elif v==2:

                    i=node.i-1

                    j=node.j

                elif v==3:

                    i=node.i+1

                    j=node.j

                if i>=0 and j>=0 and i<self.m and j<self.n:

                    flag=False

                    p=first

                    while p!=-1:

                        pi= queue[p].i

                        pj= queue[p].j

                        if pi==i and pj==j:

                            flag=True

                            break

                        p= queue[p].v

                    if self.maze[i][j]==0 and not flag:

                        node=NodeClass(i,j,first)

                        if i==self.m-1 and j==self.n-1:

                            count+=1

                            print("Path %-4d" %count,end=":")

                            path=[node]

                            p=first

                            while p!=-1:

                                path.insert(0,queue[p])

                                p=queue[p].v

                            for k in range(len(path)):

                                print("->(%d,%d)" %(path[k].i,path[k].j),end="")

                            print()

                        else:

                            queue.append(node)

                            rear+=1

            #self.showqueue(first, queue)

            first+=1

 

(4) 回到(2)，一直到队列为空为止。



<pre>
4.程序测试

1. 测试结果1

输入迷宫行数(1-9):5

输入迷宫列数(1-9):6

0 1 1 1 1 1

0 0 0 1 1 0

0 0 0 1 0 0

0 1 0 0 1 0

0 0 0 1 0 0

 

这个迷宫没有出路

 

2. 测试结果2

输入迷宫行数(1-9):3

输入迷宫列数(1-9):4

0 0 0 1

0 0 0 0

0 0 0 0

 

*****深度优先搜索*****

Path 1   :->(0,0)->(0,1)->(0,2)->(1,2)->(1,1)->(1,0)->(2,0)->(2,1)->(2,2)->(2,3)

Path 2   :->(0,0)->(0,1)->(0,2)->(1,2)->(1,1)->(2,1)->(2,2)->(2,3)

Path 3   :->(0,0)->(0,1)->(0,2)->(1,2)->(1,3)->(2,3)

Path 4   :->(0,0)->(0,1)->(0,2)->(1,2)->(2,2)->(2,3)

Path 5   :->(0,0)->(0,1)->(1,1)->(1,0)->(2,0)->(2,1)->(2,2)->(2,3)

Path 6   :->(0,0)->(0,1)->(1,1)->(1,0)->(2,0)->(2,1)->(2,2)->(1,2)->(1,3)->(2,3)

Path 7   :->(0,0)->(0,1)->(1,1)->(1,2)->(1,3)->(2,3)

Path 8   :->(0,0)->(0,1)->(1,1)->(1,2)->(2,2)->(2,3)

Path 9   :->(0,0)->(0,1)->(1,1)->(2,1)->(2,2)->(2,3)

Path 10  :->(0,0)->(0,1)->(1,1)->(2,1)->(2,2)->(1,2)->(1,3)->(2,3)

Path 11  :->(0,0)->(1,0)->(1,1)->(1,2)->(1,3)->(2,3)

Path 12  :->(0,0)->(1,0)->(1,1)->(1,2)->(2,2)->(2,3)

Path 13  :->(0,0)->(1,0)->(1,1)->(0,1)->(0,2)->(1,2)->(1,3)->(2,3)

Path 14  :->(0,0)->(1,0)->(1,1)->(0,1)->(0,2)->(1,2)->(2,2)->(2,3)

Path 15  :->(0,0)->(1,0)->(1,1)->(2,1)->(2,2)->(2,3)

Path 16  :->(0,0)->(1,0)->(1,1)->(2,1)->(2,2)->(1,2)->(1,3)->(2,3)

Path 17  :->(0,0)->(1,0)->(2,0)->(2,1)->(2,2)->(2,3)

Path 18  :->(0,0)->(1,0)->(2,0)->(2,1)->(2,2)->(1,2)->(1,3)->(2,3)

Path 19  :->(0,0)->(1,0)->(2,0)->(2,1)->(1,1)->(1,2)->(1,3)->(2,3)

Path 20  :->(0,0)->(1,0)->(2,0)->(2,1)->(1,1)->(1,2)->(2,2)->(2,3)

Path 21  :->(0,0)->(1,0)->(2,0)->(2,1)->(1,1)->(0,1)->(0,2)->(1,2)->(1,3)->(2,3)

Path 22  :->(0,0)->(1,0)->(2,0)->(2,1)->(1,1)->(0,1)->(0,2)->(1,2)->(2,2)->(2,3)

*****广度优先搜索*****

Path 1   :->(0,0)->(0,1)->(0,2)->(1,2)->(1,3)->(2,3)

Path 2   :->(0,0)->(0,1)->(0,2)->(1,2)->(2,2)->(2,3)

Path 3   :->(0,0)->(0,1)->(1,1)->(1,2)->(1,3)->(2,3)

Path 4   :->(0,0)->(0,1)->(1,1)->(1,2)->(2,2)->(2,3)

Path 5   :->(0,0)->(0,1)->(1,1)->(2,1)->(2,2)->(2,3)

Path 6   :->(0,0)->(1,0)->(1,1)->(1,2)->(1,3)->(2,3)

Path 7   :->(0,0)->(1,0)->(1,1)->(1,2)->(2,2)->(2,3)

Path 8   :->(0,0)->(1,0)->(1,1)->(2,1)->(2,2)->(2,3)

Path 9   :->(0,0)->(1,0)->(2,0)->(2,1)->(2,2)->(2,3)

Path 10  :->(0,0)->(0,1)->(0,2)->(1,2)->(1,1)->(2,1)->(2,2)->(2,3)

Path 11  :->(0,0)->(0,1)->(1,1)->(1,0)->(2,0)->(2,1)->(2,2)->(2,3)

Path 12  :->(0,0)->(0,1)->(1,1)->(2,1)->(2,2)->(1,2)->(1,3)->(2,3)

Path 13  :->(0,0)->(1,0)->(1,1)->(0,1)->(0,2)->(1,2)->(1,3)->(2,3)

Path 14  :->(0,0)->(1,0)->(1,1)->(0,1)->(0,2)->(1,2)->(2,2)->(2,3)

Path 15  :->(0,0)->(1,0)->(1,1)->(2,1)->(2,2)->(1,2)->(1,3)->(2,3)

Path 16  :->(0,0)->(1,0)->(2,0)->(2,1)->(2,2)->(1,2)->(1,3)->(2,3)

Path 17  :->(0,0)->(1,0)->(2,0)->(2,1)->(1,1)->(1,2)->(1,3)->(2,3)

Path 18  :->(0,0)->(1,0)->(2,0)->(2,1)->(1,1)->(1,2)->(2,2)->(2,3)

Path 19  :->(0,0)->(0,1)->(0,2)->(1,2)->(1,1)->(1,0)->(2,0)->(2,1)->(2,2)->(2,3)

Path 20  :->(0,0)->(0,1)->(1,1)->(1,0)->(2,0)->(2,1)->(2,2)->(1,2)->(1,3)->(2,3)

Path 21  :->(0,0)->(1,0)->(2,0)->(2,1)->(1,1)->(0,1)->(0,2)->(1,2)->(1,3)->(2,3)

Path 22  :->(0,0)->(1,0)->(2,0)->(2,1)->(1,1)->(0,1)->(0,2)->(1,2)->(2,2)->(2,3)
</pre>
