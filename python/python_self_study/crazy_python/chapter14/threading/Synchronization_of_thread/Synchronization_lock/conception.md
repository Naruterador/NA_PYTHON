###同步锁
    > 之所以之前的银行提款程序会显示错误的结果，是因为run()方法的方法不具有线程安全性——程序
      中有两个并发线程在修改Account对象;而且系统恰好在time.sleep(0.01)处执行线程切换，切换到另一个修改Account线程，所以就出了问题。

    > 为了解决这个问题，Python的threading模块引入了锁(Lock)。threading模块提供了Lock和
      RLock两个类，它们都提供了如下两个方法来加锁和释放锁。
      > acquire(blocking=True,timeout=-1):请求对Lock或RLock加锁，其中timeout参数指定加锁多少秒。
      > release():释放锁
    
    > Lock和RLock的区别如下:
      > threading.Lock:它是一个基本的锁对象，每次只能锁定一次，其余的锁请求，需等待锁释放
        后才能获取
      > threading.RLock:它代表可重入锁(Reentrant Lock)。对于可重入锁，在同一个线程中可
        以对它进行多次锁定，也可以多次释放。如果使用RLock，那么acquire()和release()方法
        必须成对出现。如果调用了n次acquire()加锁，则必须调用n次release()才能释放锁。
    > 由此可见，RLock锁具有可重入性。也就是说，同一个线程可以对已被加锁的RLock再次加锁
      RLock对象会维持一个计数器来追踪acquire()方法的嵌套调用，线程在每次调用acquire()加
      锁后，都必须显式调用release()方法来释放锁。所以，一段被锁的方法可以调用另一个被相同
      锁保护的方法。

    > Lock是控制多个线程对共享资源进行访问的工具。通常，锁提供了对共享资源的独占访问，每次
      只能有一个线程对Lock对象加锁，线程在开始访问共享资源之前应先请求获得Lock对象。当对共享资源访问完成后，程序释放对Lock对象的锁定。

###实现线程安全的控制中，比较常用的是RLock。通常使用RLock的代码格式如下:
    > 格式:
    class X:
        #定义需要保证线程安全的方法
        def m():
            #加锁
            self.lock.acquire()
            try:
                #需要保证线程安全的代码
                #……的方法体
            #使用finally块来保证释放锁
            finally:
                #修改完成，释放锁
                self.lock.release()
    > 使用RLock对象来控制线程安全，当加锁和释放锁出现在不同的作用范围时，通常建议使用final
      ly块来确保在必要时释放锁。
    > 通过使用Lock对象可以非常方便地实现线程安全的类，线程安全的类具有如下特征:
        > 该类的对象可以被多个线程安全的访问
        > 每个线程在调用该对象的任意方法之后，都将得到正确的结果
        > 每个线程在调用该对象的任意方法之后，该对象都依然保持合理的状态
    > 总体来说，不可变类的线程总是安全的因为它的对象状态不可改变；但可变对象需要额外的方法来
      保证其线程安全。例如,前面的银行取款程序中的Account就是一个可变类，它的一个名为
      self.account_no和self._balance(为了更好的封装，将balance改为_balance)两个成员
      变量都可以被改变，当两个线程同时修改Account对象的self._balance成员变量的值时，程序就出现了异常。下面我们将对银行提款程序中的Account类对self._balance的访问设置成线程
      安全的，那么只需要对修改self._balance的方法增加线程安全的控制即可。